### 菲特后台
#### 简述:
> * 菲特后台是一个不完整的react架构 有三个问题没有完善解决
> * 一是 **路由** 的问题,当前架构是基于 hasher ,crossroads
> 路由的匹配方法相对react-router比较冗余  这也是项目重构的一个优化点
> * 二是组件间的通讯是才用props在父子组件间进行通讯,将状态和方法从父级传递给子级,
> * 三是打包的路径问题,可优化为打包到build 文件 发布到线上的时候直接复制build文件夹就可以
> 也就是将源码和线上代码区分开来 ,便于源代码管理,这一点可以通过修改webpack.config.js 解决
> 这样的组件通讯方式的弊端是  不够灵活 也不利于组件的拆分  组件的复用会遇到更多的阻力
> 组件通讯是单页应用程序组件化中非常关键性的问题 
> 所以不得不承认菲特后台架构并不是一个成熟完整的 react 架构 

#### 详细约定:
> * 组件间通讯:通过props 进行子级和父级组件通讯
> * 新增一个数据,提交给后台接口的主键id 约定为 16进制的0: 0000000000000000
> * 区域信息的存储是基于 [lokijs](http://lokijs.org/#/) ,数据存储的区间是localStorage ,由于数据量较大 ,所以对区域信息数据进行浏览器本地存储,区域信息模块的数据流程: 
> * 1 初始化区域信息数据的时候  首先会查找本地数据库 如果有缓存则不再向服务器端请求数据,使用已有的本地数据库
> * 2 如果本地数据库不存在  则向服务器端请求数据 并将数据写入lokijs本地数据库
> * 开发环境需要在全局环境安装 supervisor ,命令为

 ```
 $ npm install supervisor -g 
 ```
 > 然后启动开发 服务器的命令是 
 
 ```
 $  supervisor server.js
 ```
 
 > * 编译的命令是:
 
 ```
 $ npm start
 ```
 
 > * 多页应用程序每个页面保持只有一个入口js ,js只有一个入口函数 
 > * 针对DOM 的绑定事件 要保证在dom 完成渲染之后再执行绑定函数
 > * 入口函数 要引入 babel-polyfill 实现浏览器对ES6的兼容: 
 
 ```
 import 'babel-polyfill';
 ```
 > Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。
 > 举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。